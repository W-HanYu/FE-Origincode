import{_ as s,p as a,q as i,s as e,R as o,t as c,a2 as l,Y as n,n as r}from"./framework-e1bed10d.js";const u="/FE-Origincode/assets/workloop-36ba8010.png",h={},_=e("h1",{id:"react-工作循环-workloop",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#react-工作循环-workloop","aria-hidden":"true"},"#"),o(" React 工作循环 (workLoop)")],-1),p=e("code",null,"react",-1),f=e("code",null,"scheduler",-1),k=e("code",null,"react-reconciler",-1),b=n('<p><img src="'+u+'" alt=""></p><p>本文将这两个循环分别表述为<code>任务调度循环</code>和<code>fiber构造循环</code>. 接下来从宏观角度阐述这两大循环的作用, 以及它们之间的区别和联系. 更深入的源码分析分别在<code>scheduler 调度机制</code>和<code>fiber 树构造</code>章节中详细解读.</p><ol><li><code>任务调度循环</code></li></ol>',3),m={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/Scheduler.js",target:"_blank",rel:"noopener noreferrer"},g=e("code",null,"Scheduler.js",-1),x=e("code",null,"react",-1),R=e("code",null,"task",-1),w=e("ol",{start:"2"},[e("li",null,[e("code",null,"fiber构造循环")])],-1),L={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js",target:"_blank",rel:"noopener noreferrer"},S=e("code",null,"ReactFiberWorkLoop.js",-1),O=e("p",null,[o("这两个循环对应的 js 源码不同于其他闭包(运行时就是闭包), 其中定义的全局变量, 不仅是该作用域的私有变量, 更用于"),e("code",null,"控制react应用的执行过程"),o(".")],-1),j=e("h2",{id:"区别与联系",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#区别与联系","aria-hidden":"true"},"#"),o(" 区别与联系")],-1),v=e("p",null,"区别",-1),W=e("code",null,"任务调度循环",-1),E=e("code",null,"二叉堆",-1),N=e("code",null,"堆",-1),V=e("code",null,"堆",-1),y=e("li",null,[e("code",null,"任务调度循环"),o("的逻辑偏向宏观, 它调度的是每一个任务("),e("code",null,"task"),o("), 而不关心这个任务具体是干什么的(甚至可以将"),e("code",null,"Scheduler"),o("包脱离"),e("code",null,"react"),o("使用), 具体任务其实就是执行回调函数"),e("code",null,"performSyncWorkOnRoot"),o("或"),e("code",null,"performConcurrentWorkOnRoot"),o(".")],-1),B=e("code",null,"fiber构造循环",-1),C=e("code",null,"树",-1),F=e("li",null,[e("code",null,"fiber构造循环"),o("的逻辑偏向具体实现, 它只是任务("),e("code",null,"task"),o(")的一部分(如"),e("code",null,"performSyncWorkOnRoot"),o("包括: "),e("code",null,"fiber"),o("树的构造, "),e("code",null,"DOM"),o("渲染, 调度检测), 只负责"),e("code",null,"fiber"),o("树的构造.")],-1),D=e("li",null,[e("p",null,"联系"),e("ul",null,[e("li",null,[e("code",null,"fiber构造循环"),o("是"),e("code",null,"任务调度循环"),o("中的任务("),e("code",null,"task"),o(")的一部分. 它们是从属关系, 每个任务都会重新构造一个"),e("code",null,"fiber"),o("树.")])])],-1),I=n('<h2 id="主干逻辑" tabindex="-1"><a class="header-anchor" href="#主干逻辑" aria-hidden="true">#</a> 主干逻辑</h2><p>通过上文的描述, 两大循环的分工可以总结为: 大循环(任务调度循环)负责调度<code>task</code>, 小循环(fiber 构造循环)负责实现<code>task</code> .</p><p>react 运行的主干逻辑, 即将<code>输入转换为输出</code>的核心步骤, 实际上就是围绕这两大工作循环进行展开.</p><p>结合上文的宏观概览图(展示核心包之间的调用关系), 可以将 react 运行的主干逻辑进行概括:</p><ol><li>输入: 将每一次更新(如: 新增, 删除, 修改节点之后)视为一次<code>更新需求</code>(目的是要更新<code>DOM</code>节点).</li><li>注册调度任务: <code>react-reconciler</code>收到<code>更新需求</code>之后, 并不会立即构造<code>fiber树</code>, 而是去调度中心<code>scheduler</code>注册一个新任务<code>task</code>, 即把<code>更新需求</code>转换成一个<code>task</code>.</li><li>执行调度任务(输出): 调度中心<code>scheduler</code>通过<code>任务调度循环</code>来执行<code>task</code>(<code>task</code>的执行过程又回到了<code>react-reconciler</code>包中). <ul><li><code>fiber构造循环</code>是<code>task</code>的实现环节之一, 循环完成之后会构造出最新的 fiber 树.</li><li><code>commitRoot</code>是<code>task</code>的实现环节之二, 把最新的 fiber 树最终渲染到页面上, <code>task</code>完成.</li></ul></li></ol><p>主干逻辑就是<code>输入到输出</code>这一条链路, 为了更好的性能(如<code>批量更新</code>, <code>可中断渲染</code>等功能), <code>react</code>在输入到输出的链路上做了很多优化策略, 比如本文讲述的<code>任务调度循环</code>和<code>fiber构造循环</code>相互配合就可以实现<code>可中断渲染</code>.</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节从宏观角度描述了<code>react</code>源码中的两大工作循环. 通过这两个大循环概括出<code>react</code>运行的主干逻辑. <code>react-reconciler</code>和<code>Scheduler</code>包代码量多且逻辑复杂, 但实际上大部分都是服务于这个主干. 了解这两大循环, 更容易理解<code>react</code>的整体运行链路.</p>',8);function M(q,T){const d=r("RouterLink"),t=r("ExternalLinkIcon");return a(),i("div",null,[_,e("p",null,[o("在前文("),c(d,{to:"/docs/react/principle-analysis/macro-structure.html"},{default:l(()=>[o("React 应用的宏观包结构")]),_:1}),o(")中, 介绍了"),p,o("核心包之间的依赖和调用关系, 并绘制出了概览图. 在概览图中, 可以看到有两个大的循环, 它们分别位于"),f,o("和"),k,o("包中:")]),b,e("p",null,[o("源码位于"),e("a",m,[g,c(t)]),o(", 它是"),x,o("应用得以运行的保证, 它需要循环调用, 控制所有任务("),R,o(")的调度.")]),w,e("p",null,[o("源码位于"),e("a",L,[S,c(t)]),o(", 控制 fiber 树的构造, 整个过程是一个"),c(d,{to:"/docs/react/algorithm/dfs.html"},{default:l(()=>[o("深度优先遍历")]),_:1}),o(".")]),O,j,e("ol",null,[e("li",null,[v,e("ul",null,[e("li",null,[W,o("是以"),E,o("为数据结构(详见"),c(d,{to:"/docs/react/algorithm/heapsort.html"},{default:l(()=>[o("react 算法之堆排序")]),_:1}),o("), 循环执行"),N,o("的顶点, 直到"),V,o("被清空.")]),y,e("li",null,[B,o("是以"),C,o("为数据结构, 从上至下执行深度优先遍历(详见"),c(d,{to:"/docs/react/algorithm/dfs.html"},{default:l(()=>[o("react 算法之深度优先遍历")]),_:1}),o(").")]),F])]),D]),I])}const z=s(h,[["render",M],["__file","workloop.html.vue"]]);export{z as default};
