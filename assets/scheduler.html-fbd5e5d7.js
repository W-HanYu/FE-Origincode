import{_ as l,p as i,q as r,s,t as a,a2 as p,R as n,Y as t,n as c}from"./framework-e1bed10d.js";const u="/FE-Origincode/assets/core-15259ac8.png",d={},k=s("h1",{id:"react-调度原理-scheduler",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#react-调度原理-scheduler","aria-hidden":"true"},"#"),n(" React 调度原理(scheduler)")],-1),v=s("p",null,[n("在 React 运行时中, 调度中心(位于"),s("code",null,"scheduler"),n("包), 是整个 React 运行时的中枢(其实是心脏), 所以理解"),s("code",null,"scheduler"),n("调度, 就基本把握了 React 的命门.")],-1),m=s("p",null,[n("在深入分析之前, 建议回顾一下往期与"),s("code",null,"scheduler"),n("相关的文章(这 3 篇文章不长, 共 10 分钟能浏览完):")],-1),b=s("code",null,"任务调度循环",-1),h=s("code",null,"react-reconciler",-1),f=s("code",null,"reconciler",-1),y=s("code",null,"注册调度任务",-1),_=s("code",null,"scheduler",-1),g=s("code",null,"react-reconciler",-1),w=s("code",null,"任务调度循环",-1),T=s("code",null,"task",-1),C=s("code",null,"react-reconciler",-1),L=s("code",null,"scheduler",-1),x=s("code",null,"SchedulerPriority",-1),R=s("code",null,"任务调度循环",-1),j=s("p",null,[n("了解上述基础知识之后, 再谈"),s("code",null,"scheduler"),n("原理, 其实就是在大的框架下去添加实现细节, 相对较为容易. 下面就正式进入主题.")],-1),I=s("h2",{id:"调度实现",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#调度实现","aria-hidden":"true"},"#"),n(" 调度实现")],-1),P=s("code",null,"调度中心",-1),H={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js",target:"_blank",rel:"noopener noreferrer"},S=t(`<h3 id="内核" tabindex="-1"><a class="header-anchor" href="#内核" aria-hidden="true">#</a> 内核</h3><p>该 js 文件一共导出了 8 个函数, 最核心的逻辑, 就集中在了这 8 个函数中 :</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">let</span> requestHostCallback<span class="token punctuation">;</span> <span class="token comment">// 请求及时回调: port.postMessage</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> cancelHostCallback<span class="token punctuation">;</span> <span class="token comment">// 取消及时回调: scheduledHostCallback = null</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> requestHostTimeout<span class="token punctuation">;</span> <span class="token comment">// 请求延时回调: setTimeout</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> cancelHostTimeout<span class="token punctuation">;</span> <span class="token comment">// 取消延时回调: cancelTimeout</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> shouldYieldToHost<span class="token punctuation">;</span> <span class="token comment">// 是否让出主线程(currentTime &gt;= deadline &amp;&amp; needsPaint): 让浏览器能够执行更高优先级的任务(如ui绘制, 用户输入等)</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> requestPaint<span class="token punctuation">;</span> <span class="token comment">// 请求绘制: 设置 needsPaint = true</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> getCurrentTime<span class="token punctuation">;</span> <span class="token comment">// 获取当前时间</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> forceFrameRate<span class="token punctuation">;</span> <span class="token comment">// 强制设置 yieldInterval (让出主线程的周期). 这个函数虽然存在, 但是从源码来看, 几乎没有用到</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道 react 可以在 nodejs 环境中使用, 所以在不同的 js 执行环境中, 这些函数的实现会有区别. 下面基于普通浏览器环境, 对这 8 个函数逐一分析 :</p><ol><li>调度相关: 请求或取消调度</li></ol>`,5),M={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L224-L230",target:"_blank",rel:"noopener noreferrer"},E={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L232-L234",target:"_blank",rel:"noopener noreferrer"},W={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L236-L240",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L242-L245",target:"_blank",rel:"noopener noreferrer"},U=t(`<p>这 4 个函数源码很简洁, 非常好理解, 它们的目的就是请求执行(或取消)回调函数. 现在重点介绍其中的<code>及时回调</code>(<code>延时回调</code>的 2 个函数暂时属于保留 api, 17.0.2 版本其实没有用上)</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 接收 MessageChannel 消息</span>
<span class="token keyword">const</span> <span class="token function-variable function">performWorkUntilDeadline</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略无关代码</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledHostCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 更新deadline</span>
    deadline <span class="token operator">=</span> currentTime <span class="token operator">+</span> yieldInterval<span class="token punctuation">;</span>
    <span class="token comment">// 执行callback</span>
    <span class="token function">scheduledHostCallback</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    isMessageLoopRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> channel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> port <span class="token operator">=</span> channel<span class="token punctuation">.</span>port2<span class="token punctuation">;</span>
channel<span class="token punctuation">.</span>port1<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> performWorkUntilDeadline<span class="token punctuation">;</span>

<span class="token comment">// 请求回调</span>
<span class="token function-variable function">requestHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 保存callback</span>
  scheduledHostCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMessageLoopRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    isMessageLoopRunning <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 2. 通过 MessageChannel 发送消息</span>
    port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 取消回调</span>
<span class="token function-variable function">cancelHostCallback</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很明显, 请求回调之后<code>scheduledHostCallback = callback</code>, 然后通过<code>MessageChannel</code>发消息的方式触发<code>performWorkUntilDeadline</code>函数, 最后执行回调<code>scheduledHostCallback</code>.</p><p>此处需要注意: <code>MessageChannel</code>在浏览器事件循环中属于<code>宏任务</code>, 所以调度中心永远是<code>异步执行</code>回调函数.</p><ol start="2"><li>时间切片(<code>time slicing</code>)相关: 执行时间分割, 让出主线程(把控制权归还浏览器, 浏览器可以处理用户输入, UI 绘制等紧急任务).</li></ol>`,5),O={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L22-L24",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L129-L152",target:"_blank",rel:"noopener noreferrer"},Y={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L154-L156",target:"_blank",rel:"noopener noreferrer"},q={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L168-L183",target:"_blank",rel:"noopener noreferrer"},B=s("code",null,"yieldInterval",-1),F=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> localPerformance <span class="token operator">=</span> performance<span class="token punctuation">;</span>
<span class="token comment">// 获取当前时间</span>
<span class="token function-variable function">getCurrentTime</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> localPerformance<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 时间切片周期, 默认是5ms(如果一个task运行超过该周期, 下一个task执行之前, 会把控制权归还浏览器)</span>
<span class="token keyword">let</span> yieldInterval <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> deadline <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> maxYieldInterval <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> needsPaint <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> scheduling <span class="token operator">=</span> navigator<span class="token punctuation">.</span>scheduling<span class="token punctuation">;</span>
<span class="token comment">// 是否让出主线程</span>
<span class="token function-variable function">shouldYieldToHost</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTime <span class="token operator">&gt;=</span> deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>needsPaint <span class="token operator">||</span> scheduling<span class="token punctuation">.</span><span class="token function">isInputPending</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// There is either a pending paint or a pending input.</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// There&#39;s no pending input. Only yield if we&#39;ve reached the max</span>
    <span class="token comment">// yield interval.</span>
    <span class="token keyword">return</span> currentTime <span class="token operator">&gt;=</span> maxYieldInterval<span class="token punctuation">;</span> <span class="token comment">// 在持续运行的react应用中, currentTime肯定大于300ms, 这个判断只在初始化过程中才有可能返回false</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// There&#39;s still time left in the frame.</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 请求绘制</span>
<span class="token function-variable function">requestPaint</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  needsPaint <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 设置时间切片的周期</span>
<span class="token function-variable function">forceFrameRate</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">fps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fps <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> fps <span class="token operator">&gt;</span> <span class="token number">125</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Using console[&#39;error&#39;] to evade Babel and ESLint</span>
    console<span class="token punctuation">[</span><span class="token string">&#39;error&#39;</span><span class="token punctuation">]</span><span class="token punctuation">(</span>
      <span class="token string">&#39;forceFrameRate takes a positive int between 0 and 125, &#39;</span> <span class="token operator">+</span>
        <span class="token string">&#39;forcing frame rates higher than 125 fps is not supported&#39;</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fps <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    yieldInterval <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">/</span> fps<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// reset the framerate</span>
    yieldInterval <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这 4 个函数代码都很简洁, 其功能在注释中都有解释.</p><p>注意<code>shouldYieldToHost</code>的判定条件:</p>`,3),D=t("<li><code>currentTime &gt;= deadline</code>: 只有时间超过<code>deadline</code>之后才会让出主线程(其中<code>deadline = currentTime + yieldInterval</code>). <ul><li><code>yieldInterval</code>默认是<code>5ms</code>, 只能通过<code>forceFrameRate</code>函数来修改(事实上在 v17.0.2 源码中, 并没有使用到该函数).</li><li>如果一个<code>task</code>运行时间超过<code>5ms</code>, 下一个<code>task</code>执行之前, 会把控制权归还浏览器.</li></ul></li>",1),A=s("code",null,"navigator.scheduling.isInputPending()",-1),V={href:"https://engineering.fb.com/2019/04/22/developer-tools/isinputpending-api/",target:"_blank",rel:"noopener noreferrer"},G={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L185-L218",target:"_blank",rel:"noopener noreferrer"},K=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">performWorkUntilDeadline</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>scheduledHostCallback <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1. 获取当前时间</span>
    deadline <span class="token operator">=</span> currentTime <span class="token operator">+</span> yieldInterval<span class="token punctuation">;</span> <span class="token comment">// 2. 设置deadline</span>
    <span class="token keyword">const</span> hasTimeRemaining <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 3. 执行回调, 返回是否有还有剩余任务</span>
      <span class="token keyword">const</span> hasMoreWork <span class="token operator">=</span> <span class="token function">scheduledHostCallback</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> currentTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasMoreWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 没有剩余任务, 退出</span>
        isMessageLoopRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        scheduledHostCallback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 有剩余任务, 发起新的调度</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      port<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如有异常, 重新发起调度</span>
      <span class="token keyword">throw</span> error<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    isMessageLoopRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  needsPaint <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 重置开关</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析到这里, 可以得到调度中心的内核实现图:</p><p><img src="`+u+'" alt=""></p><p>说明: 这个流程图很简单, 源码量也很少(总共不到 80 行), 但是它代表了<code>scheduler</code>的核心, 所以精华其实并不一定需要很多代码.</p><h3 id="任务队列管理" tabindex="-1"><a class="header-anchor" href="#任务队列管理" aria-hidden="true">#</a> 任务队列管理</h3><p>通过上文的分析, 我们已经知道请求和取消调度的实现原理. 调度的目的是为了消费任务, 接下来就具体分析任务队列是如何管理与实现的.</p>',6),z={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/Scheduler.js",target:"_blank",rel:"noopener noreferrer"},J={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/Scheduler.js#L62",target:"_blank",rel:"noopener noreferrer"},X=s("code",null,"taskQueue",-1),Z=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// Tasks are stored on a min heap</span>
<span class="token keyword">var</span> taskQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> timerQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意:</p>`,2),$=s("code",null,"taskQueue",-1),nn=s("li",null,[n("源码中除了"),s("code",null,"taskQueue"),n("队列之外还有一个"),s("code",null,"timerQueue"),n("队列. 这个队列是预留给延时任务使用的, 在 react@17.0.2 版本里面, 从源码中的引用来看, 算一个保留功能, 没有用到.")],-1),sn=s("h4",{id:"创建任务",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#创建任务","aria-hidden":"true"},"#"),n(" 创建任务")],-1),an=s("code",null,"unstable_scheduleCallback",-1),en={href:"https://github.com/facebook/react/blob/v17.0.2/packages/scheduler/src/Scheduler.js#L279-L359",target:"_blank",rel:"noopener noreferrer"},tn=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 省略部分无关代码</span>
<span class="token keyword">function</span> <span class="token function">unstable_scheduleCallback</span><span class="token punctuation">(</span><span class="token parameter">priorityLevel<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 获取当前时间</span>
  <span class="token keyword">var</span> currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> startTime<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> options <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span> <span class="token operator">&amp;&amp;</span> options <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 从函数调用关系来看, 在v17.0.2中,所有调用 unstable_scheduleCallback 都未传入options</span>
    <span class="token comment">// 所以省略延时任务相关的代码</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    startTime <span class="token operator">=</span> currentTime<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 2. 根据传入的优先级, 设置任务的过期时间 expirationTime</span>
  <span class="token keyword">var</span> timeout<span class="token punctuation">;</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>priorityLevel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token literal-property property">ImmediatePriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IMMEDIATE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">UserBlockingPriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">IdlePriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">IDLE_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">LowPriority</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">LOW_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token keyword">case</span> <span class="token literal-property property">NormalPriority</span><span class="token operator">:</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      timeout <span class="token operator">=</span> <span class="token constant">NORMAL_PRIORITY_TIMEOUT</span><span class="token punctuation">;</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> expirationTime <span class="token operator">=</span> startTime <span class="token operator">+</span> timeout<span class="token punctuation">;</span>
  <span class="token comment">// 3. 创建新任务</span>
  <span class="token keyword">var</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">id</span><span class="token operator">:</span> taskIdCounter<span class="token operator">++</span><span class="token punctuation">,</span>
    callback<span class="token punctuation">,</span>
    priorityLevel<span class="token punctuation">,</span>
    startTime<span class="token punctuation">,</span>
    expirationTime<span class="token punctuation">,</span>
    <span class="token literal-property property">sortIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>startTime <span class="token operator">&gt;</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 省略无关代码 v17.0.2中不会使用</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span>
    <span class="token comment">// 4. 加入任务队列</span>
    <span class="token function">push</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">,</span> newTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 请求调度</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isHostCallbackScheduled <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isPerformingWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token function">requestHostCallback</span><span class="token punctuation">(</span>flushWork<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> newTask<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>逻辑很清晰(在注释中已标明), 重点分析<code>task</code>对象的各个属性:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> newTask <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">id</span><span class="token operator">:</span> taskIdCounter<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token comment">// id: 一个自增编号</span>
  callback<span class="token punctuation">,</span> <span class="token comment">// callback: 传入的回调函数</span>
  priorityLevel<span class="token punctuation">,</span> <span class="token comment">// priorityLevel: 优先级等级</span>
  startTime<span class="token punctuation">,</span> <span class="token comment">// startTime: 创建task时的当前时间</span>
  expirationTime<span class="token punctuation">,</span> <span class="token comment">// expirationTime: task的过期时间, 优先级越高 expirationTime = startTime + timeout 越小</span>
  <span class="token literal-property property">sortIndex</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
newTask<span class="token punctuation">.</span>sortIndex <span class="token operator">=</span> expirationTime<span class="token punctuation">;</span> <span class="token comment">// sortIndex: 排序索引, 全等于过期时间. 保证过期时间越小, 越紧急的任务排在最前面</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="消费任务" tabindex="-1"><a class="header-anchor" href="#消费任务" aria-hidden="true">#</a> 消费任务</h4><p>创建任务之后, 最后请求调度<code>requestHostCallback(flushWork)</code>(<code>创建任务</code>源码中的第 5 步), <code>flushWork</code>函数作为参数被传入调度中心内核等待回调. <code>requestHostCallback</code>函数在上文调度内核中已经介绍过了, 在调度中心中, 只需下一个事件循环就会执行回调, 最终执行<code>flushWork</code>.</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 省略无关代码</span>
<span class="token keyword">function</span> <span class="token function">flushWork</span><span class="token punctuation">(</span><span class="token parameter">hasTimeRemaining<span class="token punctuation">,</span> initialTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 做好全局标记, 表示现在已经进入调度阶段</span>
  isHostCallbackScheduled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  isPerformingWork <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> previousPriorityLevel <span class="token operator">=</span> currentPriorityLevel<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. 循环消费队列</span>
    <span class="token keyword">return</span> <span class="token function">workLoop</span><span class="token punctuation">(</span>hasTimeRemaining<span class="token punctuation">,</span> initialTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 3. 还原全局标记</span>
    currentTask <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    currentPriorityLevel <span class="token operator">=</span> previousPriorityLevel<span class="token punctuation">;</span>
    isPerformingWork <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),on=s("code",null,"flushWork",-1),pn=s("code",null,"workLoop",-1),cn=s("code",null,"workLoop",-1),ln=s("code",null,"任务调度循环",-1),rn=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 省略部分无关代码</span>
<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span><span class="token parameter">hasTimeRemaining<span class="token punctuation">,</span> initialTime</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> currentTime <span class="token operator">=</span> initialTime<span class="token punctuation">;</span> <span class="token comment">// 保存当前时间, 用于判断任务是否过期</span>
  currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取队列中的第一个任务</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      currentTask<span class="token punctuation">.</span>expirationTime <span class="token operator">&gt;</span> currentTime <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span><span class="token operator">!</span>hasTimeRemaining <span class="token operator">||</span> <span class="token function">shouldYieldToHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 虽然currentTask没有过期, 但是执行时间超过了限制(毕竟只有5ms, shouldYieldToHost()返回true). 停止继续执行, 让出主线程</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> callback <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      currentPriorityLevel <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>priorityLevel<span class="token punctuation">;</span>
      <span class="token keyword">const</span> didUserCallbackTimeout <span class="token operator">=</span> currentTask<span class="token punctuation">.</span>expirationTime <span class="token operator">&lt;=</span> currentTime<span class="token punctuation">;</span>
      <span class="token comment">// 执行回调</span>
      <span class="token keyword">const</span> continuationCallback <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>didUserCallbackTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
      currentTime <span class="token operator">=</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 回调完成, 判断是否还有连续(派生)回调</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> continuationCallback <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 产生了连续回调(如fiber树太大, 出现了中断渲染), 保留currentTask</span>
        currentTask<span class="token punctuation">.</span>callback <span class="token operator">=</span> continuationCallback<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 把currentTask移出队列</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">===</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果任务被取消(这时currentTask.callback = null), 将其移出队列</span>
      <span class="token function">pop</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 更新currentTask</span>
    currentTask <span class="token operator">=</span> <span class="token function">peek</span><span class="token punctuation">(</span>taskQueue<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentTask <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 如果task队列没有清空, 返回true. 等待调度中心下一次回调</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// task队列已经清空, 返回false.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>workLoop</code>就是一个大循环, 虽然代码也不多, 但是非常精髓, 在此处实现了<code>时间切片(time slicing)</code>和<code>fiber树的可中断渲染</code>. 这 2 大特性的实现, 都集中于这个<code>while</code>循环.</p><p>每一次<code>while</code>循环的退出就是一个时间切片, 深入分析<code>while</code>循环的退出条件:</p><ol><li>队列被完全清空: 这种情况就是很正常的情况, 一气呵成, 没有遇到任何阻碍.</li><li>执行超时: 在消费<code>taskQueue</code>时, 在执行<code>task.callback</code>之前, 都会检测是否超时, 所以超时检测是以<code>task</code>为单位. <ul><li>如果某个<code>task.callback</code>执行时间太长(如: <code>fiber树</code>很大, 或逻辑很重)也会造成超时</li><li>所以在执行<code>task.callback</code>过程中, 也需要一种机制检测是否超时, 如果超时了就立刻暂停<code>task.callback</code>的执行.</li></ul></li></ol><h4 id="时间切片原理" tabindex="-1"><a class="header-anchor" href="#时间切片原理" aria-hidden="true">#</a> 时间切片原理</h4><p>消费任务队列的过程中, 可以消费<code>1~n</code>个 task, 甚至清空整个 queue. 但是在每一次具体执行<code>task.callback</code>之前都要进行超时检测, 如果超时可以立即退出循环并等待下一次调用.</p><h4 id="可中断渲染原理" tabindex="-1"><a class="header-anchor" href="#可中断渲染原理" aria-hidden="true">#</a> 可中断渲染原理</h4>`,7),un=s("code",null,"task.callback",-1),dn=s("code",null,"task.callback",-1),kn={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L1637-L1639",target:"_blank",rel:"noopener noreferrer"},vn=s("code",null,"fiber树构造循环",-1),mn=s("code",null,"continuationCallback",-1),bn=s("code",null,"fiber树构造",-1),hn=s("h2",{id:"节流防抖-throttle-debounce",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#节流防抖-throttle-debounce","aria-hidden":"true"},"#"),n(" 节流防抖 {#throttle-debounce}")],-1),fn=s("p",null,[n("通过上文的分析, 已经覆盖了"),s("code",null,"scheduler"),n("包中的核心原理. 现在再次回到"),s("code",null,"react-reconciler"),n("包中, 在调度过程中的关键路径中, 我们还需要理解一些细节.")],-1),yn=s("code",null,"注册调度任务",-1),_n=s("code",null,"ensureRootIsScheduled",-1),gn=s("code",null,"调度原理",-1),wn=s("code",null,"ensureRootIsScheduled",-1),Tn={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L674-L736",target:"_blank",rel:"noopener noreferrer"},Cn=t(`<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// ... 省略部分无关代码</span>
<span class="token keyword">function</span> <span class="token function">ensureRootIsScheduled</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">root</span><span class="token operator">:</span> FiberRoot<span class="token punctuation">,</span> <span class="token literal-property property">currentTime</span><span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前半部分: 判断是否需要注册新的调度</span>
  <span class="token keyword">const</span> existingCallbackNode <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackNode<span class="token punctuation">;</span>
  <span class="token keyword">const</span> nextLanes <span class="token operator">=</span> <span class="token function">getNextLanes</span><span class="token punctuation">(</span>
    root<span class="token punctuation">,</span>
    root <span class="token operator">===</span> workInProgressRoot <span class="token operator">?</span> workInProgressRootRenderLanes <span class="token operator">:</span> NoLanes<span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> newCallbackPriority <span class="token operator">=</span> <span class="token function">returnNextLanesPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextLanes <span class="token operator">===</span> NoLanes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 节流防抖</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>existingCallbackNode <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> existingCallbackPriority <span class="token operator">=</span> root<span class="token punctuation">.</span>callbackPriority<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>existingCallbackPriority <span class="token operator">===</span> newCallbackPriority<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">cancelCallback</span><span class="token punctuation">(</span>existingCallbackNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 后半部分: 注册调度任务 省略代码...</span>

  <span class="token comment">// 更新标记</span>
  root<span class="token punctuation">.</span>callbackPriority <span class="token operator">=</span> newCallbackPriority<span class="token punctuation">;</span>
  root<span class="token punctuation">.</span>callbackNode <span class="token operator">=</span> newCallbackNode<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>正常情况下, <code>ensureRootIsScheduled</code>函数会与<code>scheduler</code>包通信, 最后注册一个<code>task</code>并等待回调.</p>`,2),Ln=s("code",null,"task",-1),xn=s("code",null,"fiberRoot",-1),Rn=s("code",null,"fiberRoot",-1),jn=t("<li>再次进入<code>ensureRootIsScheduled</code>时(比如连续 2 次<code>setState</code>, 第 2 次<code>setState</code>同样会触发<code>reconciler运作流程</code>中的调度阶段), 如果发现处于调度中, 则需要一些节流和防抖措施, 进而保证调度性能. <ol><li>节流(判断条件: <code>existingCallbackPriority === newCallbackPriority</code>, 新旧更新的优先级相同, 如连续多次执行<code>setState</code>), 则无需注册新<code>task</code>(继续沿用上一个优先级相同的<code>task</code>), 直接退出调用.</li><li>防抖(判断条件: <code>existingCallbackPriority !== newCallbackPriority</code>, 新旧更新的优先级不同), 则取消旧<code>task</code>, 重新注册新<code>task</code>.</li></ol></li>",1),In=t('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本节主要分析了<code>scheduler</code>包中<code>调度原理</code>, 也就是<code>React两大工作循环</code>中的<code>任务调度循环</code>. 并介绍了<code>时间切片</code>和<code>可中断渲染</code>等特性在<code>任务调度循环</code>中的实现. <code>scheduler</code>包是<code>React</code>运行时的心脏, 为了提升调度性能, 注册<code>task</code>之前, 在<code>react-reconciler</code>包中做了节流和防抖等措施.</p>',2);function Pn(Hn,Sn){const o=c("RouterLink"),e=c("ExternalLinkIcon");return i(),r("div",null,[k,v,m,s("ul",null,[s("li",null,[a(o,{to:"/docs/react/principle-analysis/workloop.html"},{default:p(()=>[n("React 工作循环")]),_:1}),n(": 从宏观的角度介绍 React 体系中两个重要的循环, 其中"),b,n("就是本文的主角.")]),s("li",null,[a(o,{to:"/docs/react/principle-analysis/reconciler-workflow.html"},{default:p(()=>[n("reconciler 运作流程")]),_:1}),n(": 从宏观的角度介绍了"),h,n("包的核心作用, 并把"),f,n("分为了 4 个阶段. 其中第 2 个阶段"),y,n("串联了"),_,n("包和"),g,n("包, 其实就是"),w,n("中的一个任务("),T,n(").")]),s("li",null,[a(o,{to:"/docs/react/principle-analysis/priority.html"},{default:p(()=>[n("React 中的优先级管理")]),_:1}),n(": 介绍了 React 体系中的 3 中优先级的管理, 列出了源码中"),C,n("与"),L,n("包中关于优先级的转换思路. 其中"),x,n("控制"),R,n("中循环的顺序.")])]),j,I,s("p",null,[P,n("最核心的代码, 在"),s("a",H,[n("SchedulerHostConfig.default.js"),a(e)]),n("中.")]),S,s("ul",null,[s("li",null,[s("a",M,[n("requestHostCallback"),a(e)])]),s("li",null,[s("a",E,[n("cancelHostCallback"),a(e)])]),s("li",null,[s("a",W,[n("requestHostTimeout"),a(e)])]),s("li",null,[s("a",N,[n("cancelHostTimeout"),a(e)])])]),U,s("ul",null,[s("li",null,[s("a",O,[n("getCurrentTime"),a(e)]),n(": 获取当前时间")]),s("li",null,[s("a",Q,[n("shouldYieldToHost"),a(e)]),n(": 是否让出主线程")]),s("li",null,[s("a",Y,[n("requestPaint"),a(e)]),n(": 请求绘制")]),s("li",null,[s("a",q,[n("forceFrameRate"),a(e)]),n(": 强制设置 "),B,n("(从源码中的引用来看, 算一个保留函数, 其他地方没有用到)")])]),F,s("ul",null,[D,s("li",null,[A,n(": 这 facebook 官方贡献给 Chromium 的 api, 现在已经列入 W3C 标准("),s("a",V,[n("具体解释"),a(e)]),n("), 用于判断是否有输入事件(包括: input 框输入事件, 点击事件等).")])]),s("p",null,[n("介绍完这 8 个内部函数, 最后浏览一下完整回调的实现"),s("a",G,[n("performWorkUntilDeadline"),a(e)]),n("(逻辑很清晰, 在注释中解释):")]),K,s("p",null,[n("在"),s("a",z,[n("Scheduler.js"),a(e)]),n("中, 维护了一个"),s("a",J,[n("taskQueue"),a(e)]),n(", 任务队列管理就是围绕这个"),X,n("展开.")]),Z,s("ul",null,[s("li",null,[$,n("是一个小顶堆数组, 关于堆排序的详细解释, 可以查看"),a(o,{to:"/docs/react/algorithm/heapsort.html"},{default:p(()=>[n("React 算法之堆排序")]),_:1}),n(".")]),nn]),sn,s("p",null,[n("在"),an,n("函数中("),s("a",en,[n("源码链接"),a(e)]),n("):")]),tn,s("p",null,[on,n("中调用了"),pn,n(". 队列消费的主要逻辑是在"),cn,n("函数中, 这就是"),a(o,{to:"/docs/react/principle-analysis/workloop.html"},{default:p(()=>[n("React 工作循环")]),_:1}),n("一文中提到的"),ln,n(".")]),rn,s("p",null,[n("在时间切片的基础之上, 如果单个"),un,n("执行时间就很长(假设 200ms). 就需要"),dn,n("自己能够检测是否超时, 所以在 fiber 树构造过程中, 每构造完成一个单元, 都会检测一次超时("),s("a",kn,[n("源码链接"),a(e)]),n("), 如遇超时就退出"),vn,n(", 并返回一个新的回调函数(就是此处的"),mn,n(")并等待下一次回调继续未完成的"),bn,n(".")]),hn,fn,s("p",null,[n("在"),a(o,{to:"/docs/react/principle-analysis/reconciler-workflow.html"},{default:p(()=>[n("reconciler 运作流程")]),_:1}),n("中总结的 4 个阶段中, "),yn,n("属于第 2 个阶段, 核心逻辑位于"),_n,n("函数中. 现在我们已经理解了"),gn,n(", 再次分析"),wn,n("("),s("a",Tn,[n("源码地址"),a(e)]),n("):")]),Cn,s("ol",null,[s("li",null,[n("在"),Ln,n("注册完成之后, 会设置"),xn,n("对象上的属性("),Rn,n("是 react 运行时中的重要全局对象, 可参考"),a(o,{to:"/docs/react/principle-analysis/bootstrap.html#%E5%88%9B%E5%BB%BA%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"},{default:p(()=>[n("React 应用的启动过程")]),_:1}),n("), 代表现在已经处于调度进行中")]),jn]),In])}const En=l(d,[["render",Pn],["__file","scheduler.html.vue"]]);export{En as default};
