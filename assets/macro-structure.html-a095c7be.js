import{_ as r,p as l,q as a,s as e,R as c,t,Y as d,n as i}from"./framework-e1bed10d.js";const n="/FE-Origincode/assets/core-packages-612172bb.png",s={},u=e("h1",{id:"react-应用的宏观包结构-web-开发",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#react-应用的宏观包结构-web-开发","aria-hidden":"true"},"#"),c(" React 应用的宏观包结构(web 开发)")],-1),h={href:"https://github.com/facebook/react/tree/v17.0.2",target:"_blank",rel:"noopener noreferrer"},p=e("code",null,"@17.0.2",-1),_=e("code",null,"web",-1),b=d('<h2 id="基础包结构" tabindex="-1"><a class="header-anchor" href="#基础包结构" aria-hidden="true">#</a> 基础包结构</h2><ol><li><p>react</p><blockquote><p>react 基础包, 只提供定义 react 组件(<code>ReactElement</code>)的必要函数, 一般来说需要和渲染器(<code>react-dom</code>,<code>react-native</code>)一同使用. 在编写<code>react</code>应用的代码时, 大部分都是调用此包的 api.</p></blockquote></li><li><p>react-dom</p><blockquote><p>react 渲染器之一, 是 react 与 web 平台连接的桥梁(可以在浏览器和 nodejs 环境中使用), 将<code>react-reconciler</code>中的运行结果输出到 web 界面上. 在编写<code>react</code>应用的代码时,大多数场景下, 能用到此包的就是一个入口函数<code>ReactDOM.render(&lt;App/&gt;, document.getElementById(&#39;root&#39;))</code>, 其余使用的 api, 基本是<code>react</code>包提供的.</p></blockquote></li><li><p>react-reconciler</p><blockquote><p>react 得以运行的核心包(综合协调<code>react-dom</code>,<code>react</code>,<code>scheduler</code>各包之间的调用与配合). 管理 react 应用状态的输入和结果的输出. 将输入信号最终转换成输出信号传递给渲染器.</p></blockquote><ul><li>接受输入(<code>scheduleUpdateOnFiber</code>), 将<code>fiber</code>树生成逻辑封装到一个回调函数中(涉及<code>fiber</code>树形结构, <code>fiber.updateQueue</code>队列, 调和算法等),</li><li>把此回调函数(<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>)送入<code>scheduler</code>进行调度</li><li><code>scheduler</code>会控制回调函数执行的时机, 回调函数执行完成后得到全新的 fiber 树</li><li>再调用渲染器(如<code>react-dom</code>, <code>react-native</code>等)将 fiber 树形结构最终反映到界面上</li></ul></li><li><p>scheduler</p><blockquote><p>调度机制的核心实现, 控制由<code>react-reconciler</code>送入的回调函数的执行时机, 在<code>concurrent</code>模式下可以实现任务分片. 在编写<code>react</code>应用的代码时, 同样几乎不会直接用到此包提供的 api.</p></blockquote><ul><li>核心任务就是执行回调(回调函数由<code>react-reconciler</code>提供)</li><li>通过控制回调函数的执行时机, 来达到任务分片的目的, 实现可中断渲染(<code>concurrent</code>模式下才有此特性)</li></ul></li></ol><h2 id="宏观总览" tabindex="-1"><a class="header-anchor" href="#宏观总览" aria-hidden="true">#</a> 宏观总览</h2><h3 id="架构分层" tabindex="-1"><a class="header-anchor" href="#架构分层" aria-hidden="true">#</a> 架构分层</h3><p>为了便于理解, 可将 react 应用整体结构分为接口层(<code>api</code>)和内核层(<code>core</code>)2 个部分</p>',5),f=d("<li><p>接口层(api) <code>react</code>包, 平时在开发过程中使用的绝大部分<code>api</code>均来自此包(不是所有). 在<code>react</code>启动之后, 正常可以改变渲染的基本操作有 3 个.</p><ul><li>class 组件中使用<code>setState()</code></li><li>function 组件里面使用 hook,并发起<code>dispatchAction</code>去改变 hook 对象</li><li>改变 context(其实也需要<code>setState</code>或<code>dispatchAction</code>的辅助才能改变)</li></ul><p>以上<code>setState</code>和<code>dispatchAction</code>都由<code>react</code>包直接暴露. 所以要想 react 工作, 基本上是调用<code>react</code>包的 api 去与其他包进行交互.</p></li>",1),m=e("p",null,"内核层(core) 整个内核部分, 由 3 部分构成:",-1),k=e("li",null,[c("调度器 "),e("code",null,"scheduler"),c("包, 核心职责只有 1 个, 就是执行回调. "),e("ul",null,[e("li",null,[c("把"),e("code",null,"react-reconciler"),c("提供的回调函数, 包装到一个任务对象中.")]),e("li",null,"在内部维护一个任务队列, 优先级高的排在最前面."),e("li",null,"循环消费任务队列, 直到队列清空.")])],-1),g=e("code",null,"react-reconciler",-1),x={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples",target:"_blank",rel:"noopener noreferrer"},R=e("code",null,"HostConfig",-1),q=e("code",null,"react-dom",-1),E=e("code",null,"dom",-1),v=d("<li>接收<code>react-dom</code>包(初次<code>render</code>)和<code>react</code>包(后续更新<code>setState</code>)发起的更新请求.</li><li>将<code>fiber</code>树的构造过程包装在一个回调函数中, 并将此回调函数传入到<code>scheduler</code>包等待调度.</li>",2),O=e("code",null,"react-dom",-1),S=e("li",null,[c("引导"),e("code",null,"react"),c("应用的启动(通过"),e("code",null,"ReactDOM.render"),c(").")],-1),w={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-reconciler/README.md#practical-examples",target:"_blank",rel:"noopener noreferrer"},A=e("code",null,"HostConfig",-1),C={href:"https://github.com/facebook/react/blob/v17.0.2/packages/react-dom/src/client/ReactDOMHostConfig.js",target:"_blank",rel:"noopener noreferrer"},D=e("code",null,"react-reconciler",-1),M=e("code",null,"fiber",-1),B=d('<p>注意:</p><ul><li>此处分层的标准并非官方说法, 因为官方没有<code>架构分层</code>这样的术语.</li><li>本文只是为了深入理解 react, 在官方标准之外, 对其进行分解和剖析, 方便我们理解 react 架构.</li></ul><h3 id="内核关系" tabindex="-1"><a class="header-anchor" href="#内核关系" aria-hidden="true">#</a> 内核关系</h3><p>现将内核 3 个包的主要职责和调用关系, 绘制到一张概览图上:</p><p><img src="'+n+'" alt=""></p><p>注意:</p><ul><li>红色方块代表入口函数, 绿色方块代表出口函数.</li><li>package 之间的调用脉络就是通过板块间的入口和出口函数连接起来的.</li></ul><p>通过此概览图, 基本可以表述 react 内核层的宏观结构. 后面的章节, 会按照此图的思路深入到对应的模块逐一解读.</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本文从宏观架构的角度, 阐述了<code>react</code>核心包之间的依赖和调用关系, 使读者对<code>react</code>架构有简单的认识. 另外也给读者提供一个阅读源码的思路, 先整体浏览, 再深入分析, 各个击破.</p>',10);function H(N,V){const o=i("ExternalLinkIcon");return l(),a("div",null,[u,e("blockquote",null,[e("p",null,[c("React 工程目录的 packages 下包含 35 个包("),e("a",h,[p,c("版本"),t(o)]),c("). 其中与"),_,c("开发相关的核心包共有 4 个, 本系列近 20 篇文章, 以这 4 个包为线索进行展开, 深入理解 react 内部作用原理.")])]),b,e("ol",null,[f,e("li",null,[m,e("ol",null,[k,e("li",null,[c("构造器 "),g,c("包, 有 3 个核心职责: "),e("ol",null,[e("li",null,[c("装载渲染器, 渲染器必须实现"),e("a",x,[R,c("协议"),t(o)]),c("(如: "),q,c("), 保证在需要的时候, 能够正确调用渲染器的 api, 生成实际节点(如: "),E,c("节点).")]),v])]),e("li",null,[c("渲染器 "),O,c("包, 有 2 个核心职责: "),e("ol",null,[S,e("li",null,[c("实现"),e("a",w,[A,c("协议"),t(o)]),c("("),e("a",C,[c("源码在 ReactDOMHostConfig.js 中"),t(o)]),c("), 能够将"),D,c("包构造出来的"),M,c("树表现出来, 生成 dom 节点(浏览器中), 生成字符串(ssr).")])])])])])]),B])}const I=r(s,[["render",H],["__file","macro-structure.html.vue"]]);export{I as default};
